"name","description","data_code","global_state_code","shared_components","shared_styles","router_mode","tailwind_enabled","cdn_dependencies","custom_imports","page_ids/name","page_ids/route_path","page_ids/page_title","page_ids/sequence","page_ids/data_code","page_ids/component_code","endpoint_ids/name","endpoint_ids/endpoint_path","endpoint_ids/method","endpoint_ids/handler_code"
"Pac-Man Classic","Classic Pac-Man arcade game with authentic sounds, music, and user stat tracking","","{ gameStarted: false, soundEnabled: true, musicEnabled: true }","function SoundManager({ soundEnabled, musicEnabled }) {
  const audioCtx = useRef(null);
  const bgMusic = useRef(null);
  const sirenInterval = useRef(null);
  const sirenActive = useRef(false);
  
  const getAudioContext = useCallback(() => {
    if (!audioCtx.current || audioCtx.current.state === 'closed') {
      audioCtx.current = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioCtx.current.state === 'suspended') {
      audioCtx.current.resume();
    }
    return audioCtx.current;
  }, []);

  const playWaka = useCallback((toggle) => {
    if (!soundEnabled) return;
    const ctx = getAudioContext();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.type = 'square';
    osc.frequency.setValueAtTime(toggle ? 493 : 370, ctx.currentTime);
    osc.frequency.setValueAtTime(toggle ? 370 : 293, ctx.currentTime + 0.04);
    gain.gain.setValueAtTime(0.12, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.07);
    osc.start(ctx.currentTime);
    osc.stop(ctx.currentTime + 0.07);
  }, [soundEnabled, getAudioContext]);

  const playPowerPellet = useCallback(() => {
    if (!soundEnabled) return;
    const ctx = getAudioContext();
    [523, 659, 784, 1047].forEach((freq, i) => {
      setTimeout(() => {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.type = 'square';
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(0.12, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
        osc.start(ctx.currentTime);
        osc.stop(ctx.currentTime + 0.1);
      }, i * 40);
    });
  }, [soundEnabled, getAudioContext]);

  const playGhostEaten = useCallback(() => {
    if (!soundEnabled) return;
    const ctx = getAudioContext();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(800, ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.2);
    gain.gain.setValueAtTime(0.15, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
    osc.start(ctx.currentTime);
    osc.stop(ctx.currentTime + 0.2);
  }, [soundEnabled, getAudioContext]);

  const playDeath = useCallback(() => {
    if (!soundEnabled) return;
    const ctx = getAudioContext();
    const freqs = [493, 466, 440, 415, 392, 370, 349, 330, 311, 293, 277, 261, 246, 233, 220];
    freqs.forEach((freq, i) => {
      setTimeout(() => {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.type = 'square';
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(0.12, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.08);
        osc.start(ctx.currentTime);
        osc.stop(ctx.currentTime + 0.08);
      }, i * 90);
    });
  }, [soundEnabled, getAudioContext]);

  const playIntro = useCallback(() => {
    if (!soundEnabled) return;
    const ctx = getAudioContext();
    const melody = [
      { f: 493, d: 0.12 }, { f: 987, d: 0.12 }, { f: 739, d: 0.12 }, { f: 622, d: 0.12 },
      { f: 987, d: 0.06 }, { f: 739, d: 0.18 }, { f: 622, d: 0.24 },
      { f: 523, d: 0.12 }, { f: 1046, d: 0.12 }, { f: 783, d: 0.12 }, { f: 659, d: 0.12 },
      { f: 1046, d: 0.06 }, { f: 783, d: 0.18 }, { f: 659, d: 0.24 },
      { f: 493, d: 0.12 }, { f: 987, d: 0.12 }, { f: 739, d: 0.12 }, { f: 622, d: 0.12 },
      { f: 987, d: 0.12 }, { f: 739, d: 0.12 }, { f: 622, d: 0.12 }, { f: 659, d: 0.12 },
      { f: 698, d: 0.12 }, { f: 739, d: 0.36 }
    ];
    let time = 0;
    melody.forEach(note => {
      setTimeout(() => {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.type = 'square';
        osc.frequency.value = note.f;
        gain.gain.setValueAtTime(0.1, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + note.d * 0.9);
        osc.start(ctx.currentTime);
        osc.stop(ctx.currentTime + note.d);
      }, time * 1000);
      time += note.d;
    });
  }, [soundEnabled, getAudioContext]);

  const startSiren = useCallback((frightened = false) => {
    if (!soundEnabled || sirenActive.current) return;
    sirenActive.current = true;
    const ctx = getAudioContext();
    const playPulse = () => {
      if (!sirenActive.current) return;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.type = 'sine';
      const baseFreq = frightened ? 180 : 110;
      osc.frequency.setValueAtTime(baseFreq, ctx.currentTime);
      osc.frequency.linearRampToValueAtTime(baseFreq + (frightened ? 60 : 30), ctx.currentTime + 0.2);
      osc.frequency.linearRampToValueAtTime(baseFreq, ctx.currentTime + 0.4);
      gain.gain.setValueAtTime(0.05, ctx.currentTime);
      gain.gain.setValueAtTime(0.05, ctx.currentTime + 0.35);
      gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.4);
      osc.start(ctx.currentTime);
      osc.stop(ctx.currentTime + 0.4);
    };
    playPulse();
    sirenInterval.current = setInterval(playPulse, 450);
  }, [soundEnabled, getAudioContext]);

  const stopSiren = useCallback(() => {
    sirenActive.current = false;
    if (sirenInterval.current) {
      clearInterval(sirenInterval.current);
      sirenInterval.current = null;
    }
  }, []);

  const playLevelComplete = useCallback(() => {
    if (!soundEnabled) return;
    const ctx = getAudioContext();
    [523, 659, 784, 1047, 784, 659, 523, 659, 784, 1047, 1319, 1568].forEach((freq, i) => {
      setTimeout(() => {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.type = 'square';
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(0.12, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
        osc.start(ctx.currentTime);
        osc.stop(ctx.currentTime + 0.1);
      }, i * 60);
    });
  }, [soundEnabled, getAudioContext]);

  const playBackgroundMusic = useCallback(() => {
    if (!musicEnabled) return;
    if (!bgMusic.current) {
      bgMusic.current = new Audio('https://archive.org/download/pacmansong/vidpaw.com%20-%20PacMan%20Original%20Theme.mp3');
      bgMusic.current.loop = true;
      bgMusic.current.volume = 0.25;
    }
    bgMusic.current.play().catch(() => {});
  }, [musicEnabled]);

  const stopBackgroundMusic = useCallback(() => {
    if (bgMusic.current) {
      bgMusic.current.pause();
      bgMusic.current.currentTime = 0;
    }
  }, []);

  return { playWaka, playPowerPellet, playGhostEaten, playDeath, playIntro, startSiren, stopSiren, playLevelComplete, playBackgroundMusic, stopBackgroundMusic, getAudioContext };
}","@font-face { font-family: 'PacFont'; src: url('https://fonts.cdnfonts.com/s/15413/PAC-FONT.woff') format('woff'); } body { background: #000; font-family: 'Press Start 2P', monospace; } .pac-text { font-family: 'Press Start 2P', monospace; }","Hash Router","True","{""press-start-2p"": ""https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap""}","","Game","/","Pac-Man Classic","10","result = {}","function GamePage({ storage, user }) {
  const CELL_SIZE = 22;
  const MAZE_WIDTH = 28;
  const MAZE_HEIGHT = 31;
  const PAC_SPEED = 200;
  const GHOST_SPEED = 230;
  
  const MAZE_TEMPLATE = [
    '############################',
    '#............##............#',
    '#.####.#####.##.#####.####.#',
    '#o####.#####.##.#####.####o#',
    '#.####.#####.##.#####.####.#',
    '#..........................#',
    '#.####.##.########.##.####.#',
    '#.####.##.########.##.####.#',
    '#......##....##....##......#',
    '######.##### ## #####.######',
    '     #.##### ## #####.#     ',
    '     #.##          ##.#     ',
    '     #.## ###--### ##.#     ',
    '######.## #      # ##.######',
    '      .   #      #   .      ',
    '######.## #      # ##.######',
    '     #.## ######## ##.#     ',
    '     #.##          ##.#     ',
    '     #.## ######## ##.#     ',
    '######.## ######## ##.######',
    '#............##............#',
    '#.####.#####.##.#####.####.#',
    '#.####.#####.##.#####.####.#',
    '#o..##.......  .......##..o#',
    '###.##.##.########.##.##.###',
    '###.##.##.########.##.##.###',
    '#......##....##....##......#',
    '#.##########.##.##########.#',
    '#.##########.##.##########.#',
    '#..........................#',
    '############################'
  ];

  const SCATTER_TIMES = [7000, 20000, 7000, 20000, 5000, 20000, 5000, Infinity];

  const [gameState, setGameState] = useState('start');
  const [score, setScore] = useState(0);
  const [lives, setLives] = useState(3);
  const [level, setLevel] = useState(1);
  const [highScore, setHighScore] = useState(0);
  const [stats, setStats] = useState({ gamesPlayed: 0, totalScore: 0, dotsEaten: 0, ghostsEaten: 0, levelsCompleted: 0 });
  const [soundEnabled, setSoundEnabled] = useState(true);
  const [musicEnabled, setMusicEnabled] = useState(false);
  const [pacman, setPacman] = useState({ x: 14, y: 23, dir: 'left', nextDir: 'left', mouthOpen: true });
  const [ghosts, setGhosts] = useState([]);
  const [maze, setMaze] = useState([]);
  const [dotsRemaining, setDotsRemaining] = useState(0);
  const [ghostMultiplier, setGhostMultiplier] = useState(1);
  const [isScatter, setIsScatter] = useState(true);
  const [sirenOn, setSirenOn] = useState(false);
  const [renderTick, setRenderTick] = useState(0);
  
  const canvasRef = useRef(null);
  const wakaToggle = useRef(false);
  const mazeRef = useRef(maze);
  const pacRef = useRef(pacman);
  const ghostsRef = useRef(ghosts);
  const gameTimeRef = useRef(0);
  const modeIndexRef = useRef(0);
  const modeTimeRef = useRef(0);
  const isScatterRef = useRef(true);
  const frightenedRef = useRef(false);
  const frightenedEndRef = useRef(0);
  
  const sound = SoundManager({ soundEnabled, musicEnabled });

  useEffect(() => { mazeRef.current = maze; }, [maze]);
  useEffect(() => { pacRef.current = pacman; }, [pacman]);
  useEffect(() => { ghostsRef.current = ghosts; }, [ghosts]);

  useEffect(() => {
    const loadStats = async () => {
      const saved = await storage.get('pacmanStats', { gamesPlayed: 0, totalScore: 0, dotsEaten: 0, ghostsEaten: 0, levelsCompleted: 0 });
      const hi = await storage.get('pacmanHighScore', 0);
      setStats(saved);
      setHighScore(hi);
    };
    loadStats();
  }, [storage]);

  const saveStats = useCallback(async (ns, sc) => {
    await storage.set('pacmanStats', ns);
    if (sc > highScore) {
      await storage.set('pacmanHighScore', sc);
      setHighScore(sc);
    }
  }, [storage, highScore]);

  const initMaze = useCallback(() => {
    const m = MAZE_TEMPLATE.map(r => r.split(''));
    let dots = 0;
    for (let y = 0; y < MAZE_HEIGHT; y++)
      for (let x = 0; x < MAZE_WIDTH; x++)
        if (m[y][x] === '.' || m[y][x] === 'o') dots++;
    setMaze(m);
    mazeRef.current = m;
    setDotsRemaining(dots);
    return m;
  }, []);

  const initGhosts = useCallback(() => [
    { id: 'blinky', x: 14, y: 11, dir: 'left', color: '#FF0000', frightened: false, eaten: false, inHouse: false, exitTime: 0, scatter: { x: 25, y: 0 } },
    { id: 'pinky', x: 14, y: 14, dir: 'down', color: '#FFB8FF', frightened: false, eaten: false, inHouse: true, exitTime: 3000, scatter: { x: 2, y: 0 } },
    { id: 'inky', x: 12, y: 14, dir: 'up', color: '#00FFFF', frightened: false, eaten: false, inHouse: true, exitTime: 7000, scatter: { x: 27, y: 30 } },
    { id: 'clyde', x: 16, y: 14, dir: 'up', color: '#FFB852', frightened: false, eaten: false, inHouse: true, exitTime: 12000, scatter: { x: 0, y: 30 } }
  ], []);

  const opp = { up: 'down', down: 'up', left: 'right', right: 'left' };

  const isWall = useCallback((x, y, m, allowDoor = false) => {
    if (y === 14 && (x < 0 || x >= MAZE_WIDTH)) return false;
    if (x < 0 || x >= MAZE_WIDTH || y < 0 || y >= MAZE_HEIGHT) return true;
    const c = m[y]?.[x];
    if (c === '-') return !allowDoor;
    return c === '#';
  }, []);

  const getNext = useCallback((x, y, d) => {
    let nx = x, ny = y;
    if (d === 'up') ny--; else if (d === 'down') ny++;
    else if (d === 'left') nx--; else if (d === 'right') nx++;
    if (ny === 14) { if (nx < 0) nx = MAZE_WIDTH - 1; if (nx >= MAZE_WIDTH) nx = 0; }
    return { x: nx, y: ny };
  }, []);

  const canMove = useCallback((x, y, d, m, door = false) => !isWall(getNext(x, y, d).x, getNext(x, y, d).y, m, door), [getNext, isWall]);

  const resetRefs = useCallback(() => {
    gameTimeRef.current = 0;
    modeIndexRef.current = 0;
    modeTimeRef.current = 0;
    isScatterRef.current = true;
    frightenedRef.current = false;
    frightenedEndRef.current = 0;
    setIsScatter(true);
  }, []);

  const startGame = useCallback(() => {
    sound.playIntro();
    sound.stopBackgroundMusic();
    sound.stopSiren();
    setSirenOn(false);
    setGameState('ready');
    setTimeout(() => {
      initMaze();
      setPacman({ x: 14, y: 23, dir: 'left', nextDir: 'left', mouthOpen: true });
      const gs = initGhosts();
      setGhosts(gs);
      ghostsRef.current = gs;
      setScore(0);
      setLives(3);
      setLevel(1);
      setGhostMultiplier(1);
      resetRefs();
      setGameState('playing');
      if (musicEnabled) sound.playBackgroundMusic();
      setStats(p => { const n = { ...p, gamesPlayed: p.gamesPlayed + 1 }; storage.set('pacmanStats', n); return n; });
    }, 4200);
  }, [initMaze, initGhosts, sound, storage, musicEnabled, resetRefs]);

  const resetAfterDeath = useCallback(() => {
    sound.stopSiren();
    setSirenOn(false);
    setGameState('ready');
    setTimeout(() => {
      setPacman({ x: 14, y: 23, dir: 'left', nextDir: 'left', mouthOpen: true });
      const gs = initGhosts();
      setGhosts(gs);
      ghostsRef.current = gs;
      setGhostMultiplier(1);
      resetRefs();
      setGameState('playing');
      if (musicEnabled) sound.playBackgroundMusic();
    }, 2000);
  }, [initGhosts, sound, musicEnabled, resetRefs]);

  const advanceLevel = useCallback((sc) => {
    sound.playLevelComplete();
    sound.stopSiren();
    sound.stopBackgroundMusic();
    setSirenOn(false);
    setGameState('levelComplete');
    setLevel(l => l + 1);
    setStats(p => { const n = { ...p, levelsCompleted: p.levelsCompleted + 1 }; saveStats(n, sc); return n; });
    setTimeout(() => {
      initMaze();
      setPacman({ x: 14, y: 23, dir: 'left', nextDir: 'left', mouthOpen: true });
      const gs = initGhosts();
      setGhosts(gs);
      ghostsRef.current = gs;
      setGhostMultiplier(1);
      resetRefs();
      setGameState('playing');
      if (musicEnabled) sound.playBackgroundMusic();
    }, 3000);
  }, [initMaze, initGhosts, sound, saveStats, musicEnabled, resetRefs]);

  useEffect(() => {
    const handleKey = (e) => {
      if (gameState !== 'playing') return;
      let nd = null;
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') nd = 'up';
      else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') nd = 'down';
      else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') nd = 'left';
      else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') nd = 'right';
      if (nd) { e.preventDefault(); setPacman(p => ({ ...p, nextDir: nd })); }
    };
    window.addEventListener('keydown', handleKey);
    return () => window.removeEventListener('keydown', handleKey);
  }, [gameState]);

  useEffect(() => {
    if (gameState !== 'playing') { sound.stopSiren(); setSirenOn(false); return; }
    if (!sirenOn) { sound.startSiren(frightenedRef.current); setSirenOn(true); }
    
    const timeLoop = setInterval(() => {
      gameTimeRef.current += 50;
      
      if (frightenedRef.current && Date.now() >= frightenedEndRef.current) {
        frightenedRef.current = false;
        setGhostMultiplier(1);
        setGhosts(gs => gs.map(g => ({ ...g, frightened: false })));
        sound.stopSiren();
        sound.startSiren(false);
      }
      
      if (!frightenedRef.current) {
        modeTimeRef.current += 50;
        if (modeTimeRef.current >= SCATTER_TIMES[modeIndexRef.current]) {
          modeIndexRef.current = Math.min(modeIndexRef.current + 1, SCATTER_TIMES.length - 1);
          modeTimeRef.current = 0;
          isScatterRef.current = !isScatterRef.current;
          setIsScatter(isScatterRef.current);
          setGhosts(gs => gs.map(g => g.inHouse || g.eaten ? g : { ...g, dir: opp[g.dir] }));
        }
      }
      
      setRenderTick(t => t + 1);
    }, 50);
    
    return () => clearInterval(timeLoop);
  }, [gameState, sirenOn, sound]);

  useEffect(() => {
    if (gameState !== 'playing') return;
    
    const pacLoop = setInterval(() => {
      const m = mazeRef.current;
      setPacman(p => {
        let d = p.dir;
        if (canMove(p.x, p.y, p.nextDir, m)) d = p.nextDir;
        if (canMove(p.x, p.y, d, m)) {
          const n = getNext(p.x, p.y, d);
          return { ...p, x: n.x, y: n.y, dir: d, mouthOpen: !p.mouthOpen };
        }
        return { ...p, dir: d };
      });
    }, PAC_SPEED);
    
    return () => clearInterval(pacLoop);
  }, [gameState, canMove, getNext]);

  useEffect(() => {
    if (gameState !== 'playing') return;
    
    const ghostLoop = setInterval(() => {
      const m = mazeRef.current;
      const p = pacRef.current;
      const gt = gameTimeRef.current;
      const isFright = frightenedRef.current;
      const scatter = isScatterRef.current;
      
      setGhosts(gs => gs.map(g => {
        if (g.inHouse) {
          if (gt >= g.exitTime) return { ...g, inHouse: false, x: 14, y: 11, dir: 'left' };
          return g;
        }
        
        if (g.eaten) {
          const hx = 14, hy = 14;
          if (g.x === hx && g.y === hy) return { ...g, eaten: false, frightened: false, inHouse: true, exitTime: gt + 3000, dir: 'up' };
          const dirs = ['up', 'down', 'left', 'right'].filter(d => d !== opp[g.dir] && canMove(g.x, g.y, d, m, true));
          if (!dirs.length) dirs.push(opp[g.dir]);
          let best = dirs[0], bd = Infinity;
          dirs.forEach(d => { const n = getNext(g.x, g.y, d); const dist = (n.x - hx) ** 2 + (n.y - hy) ** 2; if (dist < bd) { bd = dist; best = d; } });
          const n = getNext(g.x, g.y, best);
          return { ...g, x: n.x, y: n.y, dir: best };
        }
        
        let tx, ty;
        if (g.frightened && isFright) {
          tx = Math.floor(Math.random() * MAZE_WIDTH);
          ty = Math.floor(Math.random() * MAZE_HEIGHT);
        } else if (scatter) {
          tx = g.scatter.x; ty = g.scatter.y;
        } else {
          switch (g.id) {
            case 'blinky': tx = p.x; ty = p.y; break;
            case 'pinky':
              tx = p.x + (p.dir === 'left' ? -4 : p.dir === 'right' ? 4 : 0);
              ty = p.y + (p.dir === 'up' ? -4 : p.dir === 'down' ? 4 : 0);
              break;
            case 'inky':
              const b = gs.find(x => x.id === 'blinky');
              const ax = p.x + (p.dir === 'left' ? -2 : p.dir === 'right' ? 2 : 0);
              const ay = p.y + (p.dir === 'up' ? -2 : p.dir === 'down' ? 2 : 0);
              tx = ax * 2 - b.x; ty = ay * 2 - b.y;
              break;
            case 'clyde':
              const dist = Math.sqrt((g.x - p.x) ** 2 + (g.y - p.y) ** 2);
              if (dist > 8) { tx = p.x; ty = p.y; }
              else { tx = g.scatter.x; ty = g.scatter.y; }
              break;
            default: tx = p.x; ty = p.y;
          }
        }
        
        const avail = ['up', 'down', 'left', 'right'].filter(d => d !== opp[g.dir] && canMove(g.x, g.y, d, m, false));
        if (!avail.length && canMove(g.x, g.y, opp[g.dir], m, false)) avail.push(opp[g.dir]);
        if (!avail.length) return g;
        
        let best = avail[0], bd = (g.frightened && isFright) ? -Infinity : Infinity;
        avail.forEach(d => {
          const n = getNext(g.x, g.y, d);
          const dist = (n.x - tx) ** 2 + (n.y - ty) ** 2;
          if ((g.frightened && isFright) ? dist > bd : dist < bd) { bd = dist; best = d; }
        });
        
        const n = getNext(g.x, g.y, best);
        return { ...g, x: n.x, y: n.y, dir: best };
      }));
    }, GHOST_SPEED);
    
    return () => clearInterval(ghostLoop);
  }, [gameState, canMove, getNext]);

  useEffect(() => {
    if (gameState !== 'playing') return;
    const c = maze[pacman.y]?.[pacman.x];
    
    if (c === '.' || c === 'o') {
      setMaze(m => { const nm = m.map(r => [...r]); nm[pacman.y][pacman.x] = ' '; mazeRef.current = nm; return nm; });
      
      if (c === '.') {
        setScore(s => s + 10);
        setStats(st => ({ ...st, dotsEaten: st.dotsEaten + 1, totalScore: st.totalScore + 10 }));
        wakaToggle.current = !wakaToggle.current;
        sound.playWaka(wakaToggle.current);
      } else {
        setScore(s => s + 50);
        frightenedRef.current = true;
        frightenedEndRef.current = Date.now() + 7000;
        setGhostMultiplier(1);
        setGhosts(gs => gs.map(g => g.inHouse || g.eaten ? g : { ...g, frightened: true, dir: opp[g.dir] }));
        sound.playPowerPellet();
        sound.stopSiren();
        sound.startSiren(true);
      }
      
      setDotsRemaining(d => {
        if (d - 1 === 0) advanceLevel(score + (c === '.' ? 10 : 50));
        return d - 1;
      });
    }
  }, [pacman.x, pacman.y, gameState, maze, score, sound, advanceLevel]);

  useEffect(() => {
    if (gameState !== 'playing') return;
    
    for (const g of ghosts) {
      if (g.inHouse) continue;
      if (g.x === pacman.x && g.y === pacman.y) {
        if (g.frightened && !g.eaten && frightenedRef.current) {
          const pts = 200 * ghostMultiplier;
          setScore(s => s + pts);
          setGhostMultiplier(m => Math.min(m * 2, 8));
          setStats(st => ({ ...st, ghostsEaten: st.ghostsEaten + 1, totalScore: st.totalScore + pts }));
          setGhosts(gs => gs.map(x => x.id === g.id ? { ...x, eaten: true, frightened: false } : x));
          sound.playGhostEaten();
        } else if (!g.eaten && !g.frightened) {
          sound.playDeath();
          sound.stopSiren();
          sound.stopBackgroundMusic();
          setSirenOn(false);
          setGameState('dying');
          setLives(l => {
            if (l - 1 <= 0) setTimeout(() => { setGameState('gameOver'); saveStats(stats, score); }, 2000);
            else setTimeout(resetAfterDeath, 100);
            return l - 1;
          });
          return;
        }
      }
    }
  }, [pacman.x, pacman.y, ghosts, gameState, ghostMultiplier, sound, resetAfterDeath, saveStats, stats, score]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    for (let y = 0; y < MAZE_HEIGHT; y++) {
      for (let x = 0; x < MAZE_WIDTH; x++) {
        const c = maze[y]?.[x];
        const px = x * CELL_SIZE, py = y * CELL_SIZE;
        if (c === '#') {
          ctx.fillStyle = '#2121DE';
          ctx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
          ctx.fillStyle = '#000';
          ctx.fillRect(px + 2, py + 2, CELL_SIZE - 4, CELL_SIZE - 4);
        } else if (c === '-') {
          ctx.fillStyle = '#FFB8FF';
          ctx.fillRect(px, py + CELL_SIZE / 2 - 2, CELL_SIZE, 4);
        } else if (c === '.') {
          ctx.fillStyle = '#FFB897';
          ctx.beginPath();
          ctx.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, 2, 0, Math.PI * 2);
          ctx.fill();
        } else if (c === 'o') {
          const pulse = Math.sin(Date.now() / 200) * 2 + 6;
          ctx.fillStyle = '#FFB897';
          ctx.beginPath();
          ctx.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, pulse, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
    
    if (gameState !== 'gameOver' && gameState !== 'dying') {
      ctx.fillStyle = '#FFFF00';
      const px = pacman.x * CELL_SIZE + CELL_SIZE / 2, py = pacman.y * CELL_SIZE + CELL_SIZE / 2;
      const ma = pacman.mouthOpen ? 0.2 : 0.02;
      let sa = 0, ea = Math.PI * 2;
      if (pacman.dir === 'right') { sa = ma * Math.PI; ea = (2 - ma) * Math.PI; }
      else if (pacman.dir === 'left') { sa = (1 + ma) * Math.PI; ea = (1 - ma) * Math.PI; }
      else if (pacman.dir === 'up') { sa = (1.5 + ma) * Math.PI; ea = (1.5 - ma) * Math.PI; }
      else if (pacman.dir === 'down') { sa = (0.5 + ma) * Math.PI; ea = (0.5 - ma) * Math.PI; }
      ctx.beginPath();
      ctx.moveTo(px, py);
      ctx.arc(px, py, CELL_SIZE / 2 + 2, sa, ea);
      ctx.closePath();
      ctx.fill();
    }
    
    const isFright = frightenedRef.current;
    ghosts.forEach(g => {
      const gx = g.x * CELL_SIZE + CELL_SIZE / 2;
      let gy = g.y * CELL_SIZE + CELL_SIZE / 2;
      if (g.inHouse) gy += Math.sin(Date.now() / 200 + g.id.length) * 4;
      
      if (g.eaten) {
        ctx.fillStyle = '#FFF';
        ctx.beginPath();
        ctx.arc(gx - 5, gy - 2, 4, 0, Math.PI * 2);
        ctx.arc(gx + 5, gy - 2, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#00F';
        let ex = g.dir === 'left' ? -2 : g.dir === 'right' ? 2 : 0;
        let ey = g.dir === 'up' ? -2 : g.dir === 'down' ? 2 : 0;
        ctx.beginPath();
        ctx.arc(gx - 5 + ex, gy - 2 + ey, 2, 0, Math.PI * 2);
        ctx.arc(gx + 5 + ex, gy - 2 + ey, 2, 0, Math.PI * 2);
        ctx.fill();
        return;
      }
      
      const gFright = g.frightened && isFright;
      const flash = gFright && frightenedEndRef.current - Date.now() < 2000 && Math.floor(Date.now() / 200) % 2;
      ctx.fillStyle = gFright ? (flash ? '#FFF' : '#2121DE') : g.color;
      ctx.beginPath();
      ctx.arc(gx, gy - 3, CELL_SIZE / 2 + 3, Math.PI, 0);
      ctx.lineTo(gx + CELL_SIZE / 2 + 3, gy + CELL_SIZE / 2 + 2);
      for (let i = 0; i < 4; i++) {
        const wx = gx + CELL_SIZE / 2 + 3 - (i + 0.5) * (CELL_SIZE + 6) / 4;
        ctx.lineTo(wx, gy + CELL_SIZE / 2 - 3);
        ctx.lineTo(wx - (CELL_SIZE + 6) / 8, gy + CELL_SIZE / 2 + 2);
      }
      ctx.closePath();
      ctx.fill();
      
      if (gFright) {
        ctx.fillStyle = flash ? '#F00' : '#FFB897';
        ctx.beginPath();
        ctx.arc(gx - 5, gy - 4, 3, 0, Math.PI * 2);
        ctx.arc(gx + 5, gy - 4, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = flash ? '#F00' : '#FFB897';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(gx - 8, gy + 5);
        for (let i = 0; i < 5; i++) ctx.lineTo(gx - 8 + i * 4, gy + 5 + (i % 2 ? -3 : 3));
        ctx.stroke();
      } else {
        ctx.fillStyle = '#FFF';
        ctx.beginPath();
        ctx.arc(gx - 5, gy - 4, 5, 0, Math.PI * 2);
        ctx.arc(gx + 5, gy - 4, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#00F';
        let ex = g.dir === 'left' ? -2 : g.dir === 'right' ? 2 : 0;
        let ey = g.dir === 'up' ? -2 : g.dir === 'down' ? 2 : 0;
        ctx.beginPath();
        ctx.arc(gx - 5 + ex, gy - 4 + ey, 2.5, 0, Math.PI * 2);
        ctx.arc(gx + 5 + ex, gy - 4 + ey, 2.5, 0, Math.PI * 2);
        ctx.fill();
      }
    });
    
    if (gameState === 'ready') {
      ctx.fillStyle = '#FFFF00';
      ctx.font = '16px ""Press Start 2P"", monospace';
      ctx.textAlign = 'center';
      ctx.fillText('READY!', canvas.width / 2, canvas.height / 2);
    }
  }, [maze, pacman, ghosts, gameState, renderTick]);

  useEffect(() => {
    if (musicEnabled && gameState === 'playing') sound.playBackgroundMusic();
    else sound.stopBackgroundMusic();
  }, [musicEnabled, gameState, sound]);

  return (
    <div className=""min-h-screen bg-black flex flex-col items-center justify-center p-4"">
      <link href=""https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"" rel=""stylesheet"" />
      <div className=""text-center mb-4"">
        <h1 className=""text-yellow-400 text-3xl mb-4"" style={{ fontFamily: 'Press Start 2P' }}>PAC-MAN</h1>
        <div className=""flex justify-center gap-8 text-white text-sm"" style={{ fontFamily: 'Press Start 2P' }}>
          <div>1UP<br /><span>{score.toString().padStart(6, '0')}</span></div>
          <div>HIGH SCORE<br /><span>{Math.max(highScore, score).toString().padStart(6, '0')}</span></div>
          <div>LEVEL<br /><span className=""text-cyan-400"">{level}</span></div>
        </div>
      </div>
      <div className=""relative border-4 border-blue-700 rounded-lg shadow-lg shadow-blue-900/50"">
        <canvas ref={canvasRef} width={MAZE_WIDTH * CELL_SIZE} height={MAZE_HEIGHT * CELL_SIZE} className=""block"" />
        {gameState === 'start' && (
          <div className=""absolute inset-0 bg-black/90 flex flex-col items-center justify-center"">
            <div className=""text-yellow-400 text-2xl mb-6"" style={{ fontFamily: 'Press Start 2P' }}>PAC-MAN</div>
            <div className=""flex gap-4 mb-4"">
              {['#FF0000', '#FFB8FF', '#00FFFF', '#FFB852'].map((c, i) => <div key={i} className=""w-6 h-6 rounded-full"" style={{ backgroundColor: c }}></div>)}
            </div>
            <button onClick={startGame} className=""bg-yellow-400 text-black px-8 py-4 rounded text-sm hover:bg-yellow-300 transition mb-4"" style={{ fontFamily: 'Press Start 2P' }}>START GAME</button>
            <div className=""text-gray-400 text-xs"" style={{ fontFamily: 'Press Start 2P' }}>ARROW KEYS or WASD</div>
          </div>
        )}
        {gameState === 'gameOver' && (
          <div className=""absolute inset-0 bg-black/90 flex flex-col items-center justify-center"">
            <div className=""text-red-500 text-2xl mb-4"" style={{ fontFamily: 'Press Start 2P' }}>GAME OVER</div>
            <div className=""text-white text-lg mb-2"" style={{ fontFamily: 'Press Start 2P' }}>SCORE: {score}</div>
            {score > highScore && <div className=""text-yellow-400 text-sm mb-4 animate-pulse"" style={{ fontFamily: 'Press Start 2P' }}>NEW HIGH SCORE!</div>}
            <button onClick={startGame} className=""bg-yellow-400 text-black px-8 py-4 rounded text-sm hover:bg-yellow-300 transition"" style={{ fontFamily: 'Press Start 2P' }}>PLAY AGAIN</button>
          </div>
        )}
      </div>
      <div className=""flex items-center gap-4 mt-4"">
        <span className=""text-white text-xs"" style={{ fontFamily: 'Press Start 2P' }}>LIVES:</span>
        {[...Array(Math.max(0, lives))].map((_, i) => <svg key={i} width=""24"" height=""24"" viewBox=""0 0 24 24""><path d=""M12 2C6 2 2 8 2 12C2 18 12 22 12 22C12 22 22 18 22 12C22 8 18 2 12 2Z"" fill=""#FFFF00"" transform=""rotate(-30 12 12)"" /></svg>)}
      </div>
      <div className=""mt-4 flex gap-4 flex-wrap justify-center"">
        <button onClick={() => setSoundEnabled(!soundEnabled)} className={`px-4 py-2 rounded text-xs ${soundEnabled ? 'bg-green-600' : 'bg-gray-700'} text-white transition`} style={{ fontFamily: 'Press Start 2P' }}>SFX {soundEnabled ? 'ON' : 'OFF'}</button>
        <button onClick={() => setMusicEnabled(!musicEnabled)} className={`px-4 py-2 rounded text-xs ${musicEnabled ? 'bg-green-600' : 'bg-gray-700'} text-white transition`} style={{ fontFamily: 'Press Start 2P' }}>MUSIC {musicEnabled ? 'ON' : 'OFF'}</button>
        <Link to=""/stats"" className=""px-4 py-2 rounded text-xs bg-blue-600 text-white"" style={{ fontFamily: 'Press Start 2P' }}>STATS</Link>
      </div>
      <div className=""mt-4 text-xs text-gray-500"" style={{ fontFamily: 'Press Start 2P' }}>
        {isScatter ? 'SCATTER' : 'CHASE'} MODE
      </div>
      <div className=""mt-4 grid grid-cols-2 gap-x-8 gap-y-2 text-xs text-gray-400"" style={{ fontFamily: 'Press Start 2P' }}>
        <div className=""flex items-center gap-2""><div className=""w-4 h-4 rounded-full bg-red-500""></div>BLINKY</div>
        <div className=""flex items-center gap-2""><div className=""w-4 h-4 rounded-full bg-pink-300""></div>PINKY</div>
        <div className=""flex items-center gap-2""><div className=""w-4 h-4 rounded-full bg-cyan-400""></div>INKY</div>
        <div className=""flex items-center gap-2""><div className=""w-4 h-4 rounded-full bg-orange-400""></div>CLYDE</div>
      </div>
    </div>
  );
}","","","",""
"","","","","","","","","","","Stats","/stats","Pac-Man Stats","10","result = {}","function StatsPage({ storage, user }) {
  const [stats, setStats] = useState({ gamesPlayed: 0, totalScore: 0, dotsEaten: 0, ghostsEaten: 0, levelsCompleted: 0 });
  const [highScore, setHighScore] = useState(0);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const loadStats = async () => {
      const savedStats = await storage.get('pacmanStats', { gamesPlayed: 0, totalScore: 0, dotsEaten: 0, ghostsEaten: 0, levelsCompleted: 0 });
      const savedHighScore = await storage.get('pacmanHighScore', 0);
      setStats(savedStats);
      setHighScore(savedHighScore);
      setLoading(false);
    };
    loadStats();
  }, [storage]);

  const resetStats = async () => {
    if (confirm('Are you sure you want to reset all stats?')) {
      const emptyStats = { gamesPlayed: 0, totalScore: 0, dotsEaten: 0, ghostsEaten: 0, levelsCompleted: 0 };
      await storage.set('pacmanStats', emptyStats);
      await storage.set('pacmanHighScore', 0);
      setStats(emptyStats);
      setHighScore(0);
    }
  };

  if (loading) {
    return (
      <div className=""min-h-screen bg-black flex items-center justify-center"">
        <div className=""text-yellow-400"" style={{fontFamily: 'Press Start 2P'}}>Loading...</div>
      </div>
    );
  }

  return (
    <div className=""min-h-screen bg-black flex flex-col items-center justify-center p-4"">
      <link href=""https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"" rel=""stylesheet"" />
      
      <h1 className=""text-yellow-400 text-2xl mb-8"" style={{fontFamily: 'Press Start 2P'}}>YOUR STATS</h1>
      
      <div className=""bg-gray-900 border-4 border-blue-600 rounded-lg p-6 w-full max-w-md"">
        <div className=""space-y-4"">
          <div className=""flex justify-between items-center border-b border-gray-700 pb-2"">
            <span className=""text-gray-400 text-xs"" style={{fontFamily: 'Press Start 2P'}}>HIGH SCORE</span>
            <span className=""text-yellow-400 text-lg"" style={{fontFamily: 'Press Start 2P'}}>{highScore.toLocaleString()}</span>
          </div>
          
          <div className=""flex justify-between items-center border-b border-gray-700 pb-2"">
            <span className=""text-gray-400 text-xs"" style={{fontFamily: 'Press Start 2P'}}>GAMES PLAYED</span>
            <span className=""text-cyan-400 text-lg"" style={{fontFamily: 'Press Start 2P'}}>{stats.gamesPlayed}</span>
          </div>
          
          <div className=""flex justify-between items-center border-b border-gray-700 pb-2"">
            <span className=""text-gray-400 text-xs"" style={{fontFamily: 'Press Start 2P'}}>DOTS EATEN</span>
            <span className=""text-white text-lg"" style={{fontFamily: 'Press Start 2P'}}>{stats.dotsEaten.toLocaleString()}</span>
          </div>
          
          <div className=""flex justify-between items-center border-b border-gray-700 pb-2"">
            <span className=""text-gray-400 text-xs"" style={{fontFamily: 'Press Start 2P'}}>GHOSTS EATEN</span>
            <span className=""text-red-400 text-lg"" style={{fontFamily: 'Press Start 2P'}}>{stats.ghostsEaten}</span>
          </div>
          
          <div className=""flex justify-between items-center border-b border-gray-700 pb-2"">
            <span className=""text-gray-400 text-xs"" style={{fontFamily: 'Press Start 2P'}}>LEVELS DONE</span>
            <span className=""text-green-400 text-lg"" style={{fontFamily: 'Press Start 2P'}}>{stats.levelsCompleted}</span>
          </div>
          
          <div className=""flex justify-between items-center pt-2"">
            <span className=""text-gray-400 text-xs"" style={{fontFamily: 'Press Start 2P'}}>AVG SCORE</span>
            <span className=""text-pink-400 text-lg"" style={{fontFamily: 'Press Start 2P'}}>
              {stats.gamesPlayed > 0 ? Math.round(stats.totalScore / stats.gamesPlayed).toLocaleString() : 0}
            </span>
          </div>
        </div>
      </div>
      
      <div className=""mt-6 flex gap-4"">
        <Link
          to=""/""
          className=""bg-yellow-400 text-black px-6 py-3 rounded text-xs hover:bg-yellow-300 transition""
          style={{fontFamily: 'Press Start 2P'}}
        >
          PLAY GAME
        </Link>
        <button
          onClick={resetStats}
          className=""bg-red-600 text-white px-6 py-3 rounded text-xs hover:bg-red-500 transition""
          style={{fontFamily: 'Press Start 2P'}}
        >
          RESET STATS
        </button>
      </div>
      
      {user && !user.is_public && (
        <div className=""mt-6 text-gray-500 text-xs"" style={{fontFamily: 'Press Start 2P'}}>
          Playing as: {user.name}
        </div>
      )}
    </div>
  );
}","","","",""
