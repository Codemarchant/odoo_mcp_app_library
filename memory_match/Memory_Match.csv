"name","description","data_code","global_state_code","shared_components","shared_styles","router_mode","tailwind_enabled","cdn_dependencies","custom_imports","page_ids/name","page_ids/route_path","page_ids/page_title","page_ids/sequence","page_ids/data_code","page_ids/component_code","endpoint_ids/name","endpoint_ids/endpoint_path","endpoint_ids/method","endpoint_ids/handler_code"
"Memory Match","A card matching memory game - flip cards to find pairs!","","{ cards: [], flipped: [], matched: [], moves: 0, gameWon: false, gameStarted: false, bgTheme: 'purple', musicTrack: 'chill', musicEnabled: false, sfxEnabled: true, gameMode: 'medium' }","const EMOJIS = ['🎮', '🎲', '🎯', '🎪', '🎨', '🎭', '🎰', '🎸', '🎻', '🎺', '🥁', '🏆', '🌟', '💎', '🚀', '🌈'];

const GAME_MODES = {
  easy: { name: 'Easy', pairs: 6, cols: 4, icon: '🌟' },
  medium: { name: 'Medium', pairs: 8, cols: 4, icon: '🔥' },
  hard: { name: 'Hard', pairs: 12, cols: 6, icon: '💠' },
  impossible: { name: 'Impossible', pairs: 16, cols: 8, icon: '💀' },
};

const BACKGROUNDS = {
  purple: 'from-slate-900 via-purple-900 to-slate-900',
  ocean: 'from-blue-900 via-cyan-900 to-teal-900',
  sunset: 'from-orange-900 via-red-900 to-pink-900',
  forest: 'from-green-900 via-emerald-900 to-teal-900',
  midnight: 'from-gray-900 via-slate-800 to-zinc-900',
  cosmic: 'from-violet-900 via-fuchsia-900 to-purple-900',
};

const MUSIC_TRACKS = {
  chill: { name: '🌙 Chill', notes: [261, 329, 392, 329], tempo: 800, wave: 'sine' },
  upbeat: { name: '🚀 Upbeat', notes: [330, 392, 494, 392, 330, 494], tempo: 300, wave: 'square' },
  retro: { name: '👾 Retro', notes: [196, 247, 294, 330, 294, 247], tempo: 400, wave: 'sawtooth' },
};

let audioCtx = null;
const getAudioCtx = () => {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
};

const playTone = (freq, duration, type = 'sine', volume = 0.3) => {
  try {
    const ctx = getAudioCtx();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    gain.gain.value = volume;
    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start();
    osc.stop(ctx.currentTime + duration);
  } catch(e) {}
};

const SFX = {
  flip: () => playTone(600, 0.1, 'sine', 0.2),
  match: () => { playTone(523, 0.1); setTimeout(() => playTone(659, 0.1), 100); setTimeout(() => playTone(784, 0.15), 200); },
  noMatch: () => playTone(200, 0.2, 'triangle', 0.2),
  win: () => { [523,659,784,1047].forEach((f,i) => setTimeout(() => playTone(f, 0.2, 'sine', 0.25), i * 150)); },
  click: () => playTone(800, 0.05, 'square', 0.1),
};

function shuffle(array) {
  const arr = [...array];
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function Card({ emoji, isFlipped, isMatched, onClick, size }) {
  const sizeClasses = { small: 'w-14 h-14 text-2xl', tiny: 'w-11 h-11 text-xl', normal: 'w-20 h-20 text-4xl' };
  return (
    <button
      onClick={onClick}
      disabled={isFlipped || isMatched}
      className={`${sizeClasses[size] || sizeClasses.normal} rounded-xl transition-all duration-300 transform ${isMatched ? 'bg-green-500 scale-95' : isFlipped ? 'bg-white shadow-lg' : 'bg-gradient-to-br from-indigo-500 to-purple-600 hover:scale-105 shadow-md'}`}
    >
      {(isFlipped || isMatched) ? emoji : '?'}
    </button>
  );
}

function StatsPanel({ stats, gameMode }) {
  const modeStats = stats[gameMode] || { played: 0, won: 0, best: null, streak: 0 };
  const mode = GAME_MODES[gameMode];
  return (
    <div className='bg-white/10 backdrop-blur rounded-xl p-4 mb-6'>
      <div className='text-center text-white/60 text-sm mb-2'>{mode.icon} {mode.name} Mode Stats</div>
      <div className='grid grid-cols-2 sm:grid-cols-4 gap-4 text-center'>
        <div>
          <div className='text-2xl font-bold text-white'>{modeStats.played}</div>
          <div className='text-purple-300 text-sm'>Games</div>
        </div>
        <div>
          <div className='text-2xl font-bold text-white'>{modeStats.won}</div>
          <div className='text-purple-300 text-sm'>Wins</div>
        </div>
        <div>
          <div className='text-2xl font-bold text-yellow-400'>{modeStats.best || '-'}</div>
          <div className='text-purple-300 text-sm'>Best</div>
        </div>
        <div>
          <div className='text-2xl font-bold text-green-400'>{modeStats.streak}</div>
          <div className='text-purple-300 text-sm'>Streak</div>
        </div>
      </div>
    </div>
  );
}

function MusicPlayer({ track, enabled, onToggle, onTrackChange }) {
  const intervalRef = useRef(null);
  const noteIndexRef = useRef(0);

  useEffect(() => {
    if (enabled) {
      const t = MUSIC_TRACKS[track];
      noteIndexRef.current = 0;
      intervalRef.current = setInterval(() => {
        const note = t.notes[noteIndexRef.current % t.notes.length];
        playTone(note, t.tempo / 1000 * 0.8, t.wave, 0.15);
        noteIndexRef.current++;
      }, t.tempo);
    } else {
      if (intervalRef.current) clearInterval(intervalRef.current);
    }
    return () => { if (intervalRef.current) clearInterval(intervalRef.current); };
  }, [enabled, track]);

  return (
    <div className='flex items-center gap-1'>
      <select
        value={track}
        onChange={e => onTrackChange(e.target.value)}
        className='px-2 py-2 rounded-lg bg-slate-800 text-white border border-white/20 outline-none cursor-pointer text-sm'
        style={{ colorScheme: 'dark' }}
      >
        {Object.entries(MUSIC_TRACKS).map(([key, t]) => (
          <option key={key} value={key} className='bg-slate-800 text-white'>{t.name}</option>
        ))}
      </select>
      <button
        onClick={onToggle}
        className={`p-2 rounded-lg transition-colors ${enabled ? 'bg-green-500/50 hover:bg-green-500/70' : 'bg-white/10 hover:bg-white/20'}`}
        title={enabled ? 'Pause Music' : 'Play Music'}
      >
        {enabled ? '🎵' : '🔈'}
      </button>
    </div>
  );
}

function SettingsBar({ globalState, setGlobalState }) {
  const { bgTheme, musicEnabled, sfxEnabled, musicTrack } = globalState;
  return (
    <div className='fixed top-4 right-4 flex flex-wrap gap-2 z-10 items-center'>
      <select
        value={bgTheme}
        onChange={e => setGlobalState(s => ({ ...s, bgTheme: e.target.value }))}
        className='px-2 py-2 rounded-lg bg-slate-800 text-white border border-white/20 outline-none cursor-pointer text-sm'
        style={{ colorScheme: 'dark' }}
      >
        <option value='purple' className='bg-slate-800 text-white'>💜 Purple</option>
        <option value='ocean' className='bg-slate-800 text-white'>🌊 Ocean</option>
        <option value='sunset' className='bg-slate-800 text-white'>🌅 Sunset</option>
        <option value='forest' className='bg-slate-800 text-white'>🌲 Forest</option>
        <option value='midnight' className='bg-slate-800 text-white'>🌙 Midnight</option>
        <option value='cosmic' className='bg-slate-800 text-white'>🌌 Cosmic</option>
      </select>
      <button
        onClick={() => setGlobalState(s => ({ ...s, sfxEnabled: !sfxEnabled }))}
        className={`p-2 rounded-lg transition-colors ${sfxEnabled ? 'bg-blue-500/50 hover:bg-blue-500/70' : 'bg-white/10 hover:bg-white/20'}`}
        title={sfxEnabled ? 'Mute SFX' : 'Enable SFX'}
      >
        {sfxEnabled ? '🔊' : '🔇'}
      </button>
      <MusicPlayer
        track={musicTrack}
        enabled={musicEnabled}
        onToggle={() => setGlobalState(s => ({ ...s, musicEnabled: !musicEnabled }))}
        onTrackChange={(t) => setGlobalState(s => ({ ...s, musicTrack: t }))}
      />
    </div>
  );
}

function GameModeSelector({ currentMode, onSelect, disabled }) {
  return (
    <div className='flex flex-wrap justify-center gap-2 mb-6'>
      {Object.entries(GAME_MODES).map(([key, mode]) => (
        <button
          key={key}
          onClick={() => onSelect(key)}
          disabled={disabled}
          className={`px-3 py-2 rounded-lg font-medium transition-all text-sm ${currentMode === key ? 'bg-white text-purple-900' : 'bg-white/10 text-white hover:bg-white/20'} ${disabled ? 'opacity-50 cursor-not-allowed' : ''}`}
        >
          {mode.icon} {mode.name}
        </button>
      ))}
    </div>
  );
}","","Hash Router","True","","","Game","/","","10","","function GamePage({ globalState, setGlobalState, storage, user }) {
  const [stats, setStats] = useState({ easy: { played: 0, won: 0, best: null, streak: 0 }, medium: { played: 0, won: 0, best: null, streak: 0 }, hard: { played: 0, won: 0, best: null, streak: 0 }, impossible: { played: 0, won: 0, best: null, streak: 0 } });
  const { sfxEnabled, bgTheme, gameMode } = globalState;

  useEffect(() => {
    storage.get('stats', null).then(savedStats => {
      if (savedStats) setStats(s => ({ ...s, ...savedStats }));
    });
    storage.get('bgTheme', null).then(bg => { if (bg) setGlobalState(s => ({ ...s, bgTheme: bg })); });
    storage.get('gameMode', null).then(mode => { if (mode) setGlobalState(s => ({ ...s, gameMode: mode })); });
  }, []);

  useEffect(() => { if (bgTheme) storage.set('bgTheme', bgTheme); }, [bgTheme]);
  useEffect(() => { if (gameMode) storage.set('gameMode', gameMode); }, [gameMode]);

  const saveStats = async (newStats) => {
    setStats(newStats);
    await storage.set('stats', newStats);
  };

  const startGame = async () => {
    if (sfxEnabled) SFX.click();
    const mode = GAME_MODES[gameMode];
    const selectedEmojis = EMOJIS.slice(0, mode.pairs);
    const pairs = [...selectedEmojis, ...selectedEmojis];
    const shuffled = shuffle(pairs).map((emoji, i) => ({ id: i, emoji }));
    
    const newStats = { ...stats };
    newStats[gameMode] = { ...newStats[gameMode], played: newStats[gameMode].played + 1 };
    await saveStats(newStats);
    
    setGlobalState(s => ({ ...s, cards: shuffled, flipped: [], matched: [], moves: 0, gameWon: false, gameStarted: true }));
  };

  const handleWin = async (moves) => {
    if (sfxEnabled) SFX.win();
    const modeStats = stats[gameMode];
    const newBest = (modeStats.best === null || moves < modeStats.best) ? moves : modeStats.best;
    const newStats = { ...stats };
    newStats[gameMode] = {
      ...modeStats,
      won: modeStats.won + 1,
      best: newBest,
      streak: modeStats.streak + 1,
    };
    await saveStats(newStats);
  };

  const handleCardClick = (id) => {
    const { flipped, matched, cards, moves } = globalState;
    if (flipped.length === 2 || flipped.includes(id) || matched.includes(id)) return;

    if (sfxEnabled) SFX.flip();
    const newFlipped = [...flipped, id];
    setGlobalState(s => ({ ...s, flipped: newFlipped }));

    if (newFlipped.length === 2) {
      const [first, second] = newFlipped;
      const firstCard = cards.find(c => c.id === first);
      const secondCard = cards.find(c => c.id === second);
      const newMoves = moves + 1;

      if (firstCard.emoji === secondCard.emoji) {
        if (sfxEnabled) setTimeout(() => SFX.match(), 100);
        const newMatched = [...matched, first, second];
        const won = newMatched.length === cards.length;
        setGlobalState(s => ({ ...s, matched: newMatched, flipped: [], moves: newMoves, gameWon: won }));
        if (won) handleWin(newMoves);
      } else {
        setTimeout(() => {
          if (sfxEnabled) SFX.noMatch();
          setGlobalState(s => ({ ...s, flipped: [], moves: newMoves }));
        }, 800);
      }
    }
  };

  const handleModeChange = (mode) => {
    if (sfxEnabled) SFX.click();
    setGlobalState(s => ({ ...s, gameMode: mode }));
  };

  const { cards, flipped, matched, moves, gameWon, gameStarted } = globalState;
  const bgClass = BACKGROUNDS[bgTheme] || BACKGROUNDS.purple;
  const mode = GAME_MODES[gameMode];
  const cardSize = gameMode === 'impossible' ? 'tiny' : gameMode === 'hard' ? 'small' : 'normal';
  const modeStats = stats[gameMode] || { played: 0, won: 0, best: null, streak: 0 };

  return (
    <div className={`min-h-screen bg-gradient-to-br ${bgClass} flex flex-col items-center justify-center p-4 transition-all duration-500`}>
      <SettingsBar globalState={globalState} setGlobalState={setGlobalState} />
      
      <h1 className='text-4xl font-bold text-white mb-2 mt-12'>🏆 Memory Match</h1>
      {user.name && <p className='text-white/60 mb-4'>Playing as {user.name}</p>}
      
      <StatsPanel stats={stats} gameMode={gameMode} />
      
      <GameModeSelector currentMode={gameMode} onSelect={handleModeChange} disabled={gameStarted && !gameWon} />

      {!gameStarted ? (
        <div className='text-center'>
          <p className='text-white/60 mb-4'>{mode.icon} {mode.name}: {mode.pairs} pairs ({mode.pairs * 2} cards)</p>
          <button onClick={startGame} className='px-8 py-4 bg-gradient-to-r from-pink-500 to-purple-600 text-white text-xl font-bold rounded-xl hover:scale-105 transition-transform shadow-lg'>
            {modeStats.played > 0 ? 'Play Again' : 'Start Game'}
          </button>
        </div>
      ) : gameWon ? (
        <div className='text-center'>
          <div className='text-6xl mb-4'>{gameMode === 'impossible' ? '💀' : '🎉'}</div>
          <p className='text-2xl text-white mb-2'>{gameMode === 'impossible' ? 'LEGENDARY!' : 'You Won!'}</p>
          <p className='text-white/60 mb-2'>{mode.icon} {mode.name} - {moves} moves</p>
          {modeStats.best === moves && <p className='text-yellow-400 font-bold mb-2'>🌟 New Best Score!</p>}
          <p className='text-green-400 mb-4'>🔥 {modeStats.streak} win streak in {mode.name}!</p>
          <button onClick={startGame} className='px-6 py-3 bg-gradient-to-r from-green-500 to-emerald-600 text-white font-bold rounded-xl hover:scale-105 transition-transform'>
            Play Again
          </button>
        </div>
      ) : (
        <>
          <div className='flex gap-4 mb-4 text-white'>
            <span className='bg-white/10 px-4 py-2 rounded-lg'>Moves: {moves}</span>
            <span className='bg-white/10 px-4 py-2 rounded-lg'>Pairs: {matched.length / 2} / {mode.pairs}</span>
          </div>
          <div className='grid gap-2' style={{ gridTemplateColumns: `repeat(${mode.cols}, minmax(0, 1fr))` }}>
            {cards.map(card => (
              <Card
                key={card.id}
                emoji={card.emoji}
                isFlipped={flipped.includes(card.id)}
                isMatched={matched.includes(card.id)}
                onClick={() => handleCardClick(card.id)}
                size={cardSize}
              />
            ))}
          </div>
          <button onClick={() => setGlobalState(s => ({ ...s, gameStarted: false, cards: [], flipped: [], matched: [], moves: 0 }))} className='mt-6 px-4 py-2 text-white/60 hover:text-white transition-colors'>
            ← Back to Menu
          </button>
        </>
      )}
    </div>
  );
}","","","",""
